// I would like to thank Vencord... for just existing, I heavily used it as a reference for this. -Lea

const { debounce } = require('powercord/util');

/**
* @typedef RegexReplacement
* @property {RegExp} match The regex to match
* @property {string|function} replace Either a string or function to replace the match with
* in the case of a function, refer to https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_function_as_the_replacement
*/

/**
* @callback PatchReplacer
* @param {string} source The source of the module
* @returns {string} The patched source
*/

/**
* @typedef Patch
* @property {string} [findModule] Only runs the replacments if a module's source contains this literal string, optional but recommended
* @property {(PatchReplacer|RegexReplacement)[]} replacements A list of replacmenets to apply on a module
*/

// lazily required since otherwise we have a circular dependency (index -> old.webpack -> lazy -> index)
let pcWebpack;

let patchQueue = [];
const globalPatches = [];

function _patchModuleSource (mod, patches) {
  const originalSource = mod.toString();

  const patchedSource = patches.reduce((source, patch) => {
    if (patch.findModule && !source.includes(patch.findModule)) {
      return source;
    }

    const result = patch.replacements.reduce((source, patch) => patch(source), source);

    if (result === source) {
      return source;
    }

    return result;
  }, originalSource);

  if (patchedSource === originalSource) {
    return mod;
  }

  // eslint-disable-next-line no-eval
  return eval(patchedSource);
}

// We only use this in the lazy patcher. No external consumers should rely on this.
function patchModule (mod) {
  return _patchModuleSource(mod, globalPatches);
}

function applyPatches () {
  const wp = pcWebpack ?? (pcWebpack = require('.'));

  webpackChunkdiscord_app.forEach(c => Object.entries(c[1]).forEach(([ id, mod ]) => {
    const patched = _patchModuleSource(mod, patchQueue);
    if (patched === mod) {
      return;
    }

    const cachedModule = wp.instance.cache[id];
    if (cachedModule) {
      patched(cachedModule, cachedModule.exports, wp.instance.require);
    }

    c[1][id] = patched;
  }));

  globalPatches.push(...patchQueue);
  patchQueue = [];
}

const applyPatchesDebounced = debounce(applyPatches, 100);

/**
 * Applies the given patches to all currently loaded modules, as well as lazily loaded modules
 * @param {Patch[]} patches An array of patches to apply
 */
function patchPlaintext (patches) {
  patchQueue.push(...patches.map(patch => ({ ...patch,
    replacements: patch.replacements.map(replacement => typeof replacement === 'function'
      ? replacement
      : (source) => source.replace(replacement.match, replacement.replace)) })));
  applyPatchesDebounced();
}

module.exports = {
  patchPlaintext,
  patchModule
};
