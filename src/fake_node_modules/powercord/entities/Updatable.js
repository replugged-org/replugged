const Events = require('events');
const { join } = require('path');
const { existsSync } = require('fs');
const { head } = require('powercord/http');

const TIMEOUT = 10e3;

/**
 * @property {String} entityID
 * @property {String} entityPath
 * @property {String} updateIdentifier
 */
class Updatable extends Events {
  constructor (basePath, entityType, entityID, updateIdentifier) {
    super();
    this.basePath = basePath;
    this.entityType = entityType;
    if (!this.entityID) {
      // It might be pre-defined by plugin manager
      this.entityID = entityID;
    }
    this.entityPath = join(this.basePath, this.entityID);
    if (!updateIdentifier) {
      updateIdentifier = `${this.basePath.split(/[\\/]/).pop()}_${this.entityID}`;
    }
    this.updateIdentifier = updateIdentifier;

    this.__migrateIfNecessary();
  }

  get manifestFilename () {
    switch (this.entityType) {
      case 'theme':
        return 'powercord_manifest.json';
      case 'base':
        return 'package.json';
    }
    return 'manifest.json';
  }

  /**
   * @returns {Boolean} Whether this can be updated or not
   */
  isUpdatable () {
    return existsSync(join(this.basePath, this.entityID, '.git')) && !this.__shortCircuit;
  }

  async _checkForUpdates () {
    try {
      await PowercordNative.exec('git fetch', {
        cwd: this.entityPath,
        timeout: TIMEOUT
      });
      const gitStatus = await PowercordNative.exec('git status -uno', {
        cwd: this.entityPath,
        timeout: TIMEOUT
      }).then(({ stdout }) => stdout.toString());

      return gitStatus.includes('git pull');
    } catch (e) {
      return false;
    }
  }

  async _getUpdateCommits (manifestOnly) {
    const commits = [];
    const upstream = await this.getUpstreamBranch();
    if (upstream === null) {
      return commits;
    }

    let gitLogCmd = `git log --format="%H -- %an -- %s" ..${upstream}`;
    if (manifestOnly) {
      gitLogCmd += ` -- ${this.manifestFilename}`;
    }

    const gitLog = await PowercordNative.exec(gitLogCmd, {
      cwd: this.entityPath,
      timeout: TIMEOUT
    }).then(({ stdout }) => stdout.toString());

    const lines = gitLog.split('\n');
    lines.pop();
    lines.forEach(line => {
      const data = line.split(' -- ');
      commits.push({
        id: data.shift(),
        author: data.shift(),
        message: data.shift()
      });
    });

    return commits;
  }

  async _getUpdateCommit () {
    const latestCommits = await this._getUpdateCommits(true);
    if (!latestCommits[0]) {
      return null;
    }

    let latestVersion;
    for (const commit of latestCommits) {
      const version = await this._getCommitVersion(commit.id);
      if (latestVersion && latestVersion !== version) {
        return;
      }
    }
  }

  async _getCommitVersion (commitHash) {
    try {
      const gitManifest = await PowercordNative.exec(`git show ${commitHash}:${this.manifestFilename}`, {
        cwd: this.entityPath,
        timeout: TIMEOUT
      }).then(({ stdout }) => stdout.toString());

      const manifest = JSON.parse(gitManifest);
      return manifest?.version ?? null;
    } catch (e) {
      return null;
    }
  }

  async _getUpdateInfo () {
    const latestCommits = await this._getUpdateCommits(true);
    if (!latestCommits[0]) {
      return null;
    }

    let updateInfo;
    for (const commit of latestCommits) {
      const version = await this._getCommitVersion(commit.id);

      if (updateInfo && updateInfo.version !== version) {
        return updateInfo;
      }

      updateInfo = { ...commit,
        version };
    }

    return updateInfo;
  }

  async _update (force = false, commitHash) {
    try {
      let command = 'git pull --ff-only';
      if (commitHash) {
        command = `git merge --ff-only ${commitHash}`;
      }
      if (force) {
        const upstream = await this.getUpstreamBranch();
        if (upstream) {
          command = `git reset --hard origin/${upstream}`;
        }
      }
      await PowercordNative.exec(command, { cwd: this.entityPath }).then(({ stdout }) => stdout.toString());
      return true;
    } catch (e) {
      return false;
    }
  }

  /**
   * Fetches the git repository for this entity
   * @returns {Promise<String|null>}
   */
  async getGitRepo () {
    try {
      return await PowercordNative.exec('git remote get-url origin', {
        cwd: this.entityPath,
        timeout: TIMEOUT
      }).then((r) => r.stdout.toString().match(/github\.com[:/]([\w-_]+\/[\w-_]+)/)?.[1] ||
          r.stdout.toString().trim().match(/(.*):(.*\/.*)/)?.[2]);
    } catch (e) {
      console.warn('Failed to fetch git origin url; ignoring.');
      return null;
    }
  }

  /**
   * Fetches the current branch name for this entity
   * @returns {Promise<String|null>}
   */
  getBranch () {
    return PowercordNative.exec('git branch', {
      cwd: this.entityPath,
      timeout: TIMEOUT
    }).then(({ stdout }) => stdout.toString().split('\n').find(l => l.startsWith('*')).slice(2).trim());
  }

  /**
   * Fetches the symbolic ref for HEAD
   * Returns null if HEAD is in detatched state
   * @returns {Promise<String|null>}
   */
  getRef () {
    return PowercordNative.exec('git symbolic-ref -q HEAD', {
      cwd: this.entityPath,
      timeout: TIMEOUT
    })
      .then(({ stdout }) => stdout.toString().trim())
      .catch(() => null);
  }

  /**
   * Fetches the remote branch that is being tracked
   * Returns null if HEAD is in detatched state
   * @returns {Promise<String|null>}
   */
  async getUpstreamBranch () {
    const ref = await this.getRef();
    if (ref === null) {
      return null;
    }
    return PowercordNative.exec(`git for-each-ref --format="%(upstream:short)" "${ref}"`, {
      cwd: this.entityPath,
      timeout: TIMEOUT
    }).then(({ stdout }) => stdout.toString().trim());
  }

  async __migrateIfNecessary () {
    if (!this.isUpdatable()) {
      return;
    }

    const repo = await this.getGitRepo();
    if (!repo) {
      return;
    }

    const url = `https://github.com/${repo}`;
    const newUrl = await this.__followRedirects(url);
    if (!newUrl) {
      this.__shortCircuit = true;
    } else if (url !== newUrl) {
      console.debug('[Updater] Migrating %s to repository %s', this.entityID, newUrl);
      await PowercordNative.exec(`git remote set-url origin "${newUrl}"`, { cwd: this.entityPath });
    }
  }

  async __followRedirects (url) {
    let code = -1;
    do {
      try {
        const res = await head(url);
        code = res.statusCode;
        if (code === 301 || code === 302) {
          url = res.headers.location;
        }
      } catch (e) {
        return false;
      }
    } while (code === 301 || code === 302);
    return url;
  }
}

module.exports = Updatable;
