const { existsSync } = require('fs');
const { join } = require('path');
const { sleep, createElement } = require('powercord/util');
const { resolveCompiler } = require('powercord/compilers');
const Updatable = require('./Updatable');

/**
 * Main class for Replugged plugins
 * @property {Boolean} ready Whether the plugin is ready or not
 * @property {SettingsCategory} settings Plugin settings
 * @property {Object.<String, Compiler>} styles Styles the plugin loaded
 * @abstract
 */
class Plugin extends Updatable {
  constructor () {
    super(powercord.pluginManager.pluginDir, 'plugin');
    this.settings = powercord.api.settings.buildCategoryObject(this.entityID);
    this.ready = false;
    this.styles = {};
  }

  // Getters
  get isInternal () {
    return this.entityID.startsWith('pc-');
  }

  get dependencies () {
    return this.manifest.dependencies;
  }

  get optionalDependencies () {
    return this.manifest.optionalDependencies;
  }

  get effectiveOptionalDependencies () {
    const deps = this.manifest.optionalDependencies;
    const disabled = powercord.settings.get('disabledPlugins', []);
    return deps.filter(d => powercord.pluginManager.get(d) !== void 0 && !disabled.includes(d));
  }

  get allDependencies () {
    return this.dependencies.concat(this.optionalDependencies);
  }

  get allEffectiveDependencies () {
    return this.dependencies.concat(this.effectiveOptionalDependencies);
  }

  get dependents () {
    const dependents = [ ...powercord.pluginManager.plugins.values() ].filter(p => p.manifest.dependencies.includes(this.entityID));
    return [ ...new Set(dependents.map(d => d.entityID).concat(...dependents.map(d => d.dependents))) ];
  }

  get color () {
    return '#7289da';
  }

  /**
   * Loads a plugin stylesheet. Will automatically get removed at plugin unload.
   * @param {String} path Stylesheet path. Either absolute or relative to the plugin root
   */
  loadStylesheet (path) {
    let resolvedPath = path;
    if (!existsSync(resolvedPath)) {
      // Assume it's a relative path and try resolving it
      resolvedPath = join(powercord.pluginManager.pluginDir, this.entityID, path);

      if (!existsSync(resolvedPath)) {
        throw new Error(`Cannot find "${path}"! Make sure the file exists and try again.`);
      }
    }

    const id = Math.random().toString(36).slice(2);
    const compiler = resolveCompiler(resolvedPath);
    const style = createElement('style', {
      id: `style-${this.entityID}-${id}`,
      'data-powercord': true,
      'data-plugin': true
    });

    document.head.appendChild(style);
    const compile = async () => (style.innerHTML = await compiler.compile());
    this.styles[id] = {
      compiler,
      compile
    };

    compiler.enableWatcher();
    compiler.on('src-update', compile);
    return compile();
  }

  // Logging
  log (...data) {
    console.log(`%c[Replugged:Plugin:${this.constructor.name}]`, `color: ${this.color}`, ...data);
  }

  debug (...data) {
    console.debug(`%c[Replugged:Plugin:${this.constructor.name}]`, `color: ${this.color}`, ...data);
  }

  warn (...data) {
    console.warn(`%c[Replugged:Plugin:${this.constructor.name}]`, `color: ${this.color}`, ...data);
  }

  error (...data) {
    console.error(`%c[Replugged:Plugin:${this.constructor.name}]`, `color: ${this.color}`, ...data);
  }

  // Update
  async _update (force = false, commitHash) {
    const success = await super._update(force, commitHash);
    if (success && this.ready) {
      await powercord.pluginManager.remount(this.entityID);
    }
    return success;
  }

  // Internals
  async _load () {
    try {
      while (!this.allEffectiveDependencies.every(pluginName => powercord.pluginManager.get(pluginName).ready)) {
        await sleep(1);
      }

      if (typeof this.startPlugin === 'function') {
        await this.startPlugin();
      }

      this.log('Plugin loaded');
    } catch (e) {
      this.error('An error occurred during initialization!', e);
    } finally {
      this.ready = true;
    }
  }

  async _unload () {
    try {
      for (const id in this.styles) {
        this.styles[id].compiler.on('src-update', this.styles[id].compile);
        this.styles[id].compiler.disableWatcher();
        document.getElementById(`style-${this.entityID}-${id}`).remove();
      }

      this.styles = {};
      if (typeof this.pluginWillUnload === 'function') {
        await this.pluginWillUnload();
      }

      this.log('Plugin unloaded');
    } catch (e) {
      this.error('An error occurred during shutting down! It\'s heavily recommended reloading Discord to ensure there are no conflicts.', e);
    } finally {
      this.ready = false;
    }
  }
}

module.exports = Plugin;
